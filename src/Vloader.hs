{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module Vloader where

import Control.Exception (try)
import Data.List (intercalate, isSuffixOf)
import Data.String (IsString (fromString))
import Data.Text (Text, replace, stripSuffix, unpack)
import Data.Text.Lazy (toStrict)
import Data.Yaml (FromJSON (parseJSON), ParseException, Value (Object), YamlException, decode, decodeFileEither, prettyPrintParseException, (.:))
import GHC.Base (IO (IO))
import GHC.IO.Exception (IOException (IOError))
import GHC.TypeLits (ErrorMessage)
import Options.Applicative (Parser, ParserInfo, fullDesc, header, help, helper, info, long, metavar, progDesc, short, strOption, value, (<**>))
import System.Directory (getDirectoryContents, getHomeDirectory)
import System.FilePath ()
import System.IO ()

data ModConfig = ModConfig
  { mod_path :: String,
    res_file :: String,
    modules :: [String]
  }
  deriving (Show)

type ModName = String

instance FromJSON ModConfig where
  parseJSON (Object o) =
    ModConfig
      <$> o .: "mod_path"
      <*> o .: "res_file"
      <*> o .: "modules"
  parseJSON _ = error "Error Parsing Config file "

newtype Config = Config
  { conf_file :: String
  }

config :: Parser Config
config =
  Config
    <$> strOption
      ( long "cfg"
          <> value "~/.vmod/vmod.yml"
          <> metavar "CFG_FILE"
          <> help "provide full path to the config file"
      )

getOpts :: ParserInfo Config
getOpts =
  info
    (config <**> helper)
    ( fullDesc
        <> progDesc "VmodLoader is used to bundle lua modules"
        <> header "V Mod Loader -Lua Module Bundler"
    )

border :: [Char]
border = concat $ replicate 30 "="

getMods :: String -> String -> IO String
getMods mod_path mod_name = do
  dir_files <- try . getDirectoryContents $ mod_path ++ "/" ++ mod_name :: IO (Either IOError [FilePath])
  case dir_files of
    Right mods -> return $modgen mod_name mods
    Left err -> "" <$ putStrLn ("\nError parsing Module : " ++ mod_name ++ "\n>> [Error]: " ++ show err ++ "\n")

modgen :: String -> [FilePath] -> String
modgen mod_name dir_files =
  let mod_files = filter (isSuffixOf ".lua") dir_files
      header = ["-- " ++ border, "--    MOD : " ++ mod_name, "-- " ++ border]
      lua_mods = map (\mod -> "require(\"" ++ mod_name ++ "." ++ fromMaybeMod (sanitizeLua mod) ++ "\")") mod_files
      lua_res = header ++ lua_mods
   in intercalate "\n" lua_res

writeMods :: [ModName] -> String -> IO ()
writeMods lua_mods res_file =
  writeFile (res_file ++ ".lua") $intercalate "\n" $banner ++ lua_mods
  where
    banner = ["-- " ++ border, "-- GENERATED BY V MOD LOADER : )", "-- " ++ border ++ "\n\n"]

getConfig :: FilePath -> IO ModConfig
getConfig conf_file = do
  home <- getHomeDirectory
  file <- decodeFileEither (replaceHome conf_file home) :: IO (Either ParseException ModConfig)
  case file of
    Left pe -> error $ " ** Config Error.\n>> Ensure that the config is in the specified directory \n\n [Error] : \n  >>" ++ prettyPrintParseException pe
    Right mc -> return mc

sanitizePath :: ModConfig -> Maybe ModConfig
sanitizePath ModConfig {mod_path, res_file, modules} =
  do
    let md_p
          | last mod_path == '/' = init mod_path
          | otherwise = mod_path
        res_f
          | ".lua" `isSuffixOf` res_file = sanitizeLua res_file
          | otherwise = Just res_file
    res_f >>= (\res -> Just $ ModConfig md_p res modules)

sanitizeLua :: String -> Maybe ModName
sanitizeLua mod_file = unpack <$> stripSuffix ".lua" (fromString mod_file)

replaceHome :: FilePath -> FilePath -> FilePath
replaceHome conf_path home =
  unpack $replace "~" home_file conf_file
  where
    home_file = fromString home
    conf_file = fromString conf_path

fromMaybeMod :: Maybe ModName -> ModName
fromMaybeMod = \case
  Just mod -> mod
  Nothing -> error "Unable to remove lua extension "

fromMaybeConfig :: Maybe ModConfig -> ModConfig
fromMaybeConfig = \case
  Just mod -> mod
  Nothing -> error "Unable to parse Config .Please Ensure that the config contains required fields\n"
