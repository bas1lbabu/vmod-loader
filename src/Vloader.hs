{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module Vloader where

import Data.List (intercalate, isSuffixOf)
import Data.String (IsString (fromString))
import Data.Text (Text, stripSuffix, unpack)
import Data.Text.Lazy (toStrict)
import Data.Yaml (FromJSON (parseJSON), ParseException, Value (Object), decode, decodeFileEither, prettyPrintParseException, (.:))
import GHC.TypeLits (ErrorMessage (Text))
import System.Directory (getDirectoryContents)
import System.FilePath ()
import System.IO ()

data ModConfig = ModConfig
  { mod_path :: String,
    res_file :: String,
    modules :: [String]
  }
  deriving (Show)

instance FromJSON ModConfig where
  parseJSON (Object o) =
    ModConfig
      <$> o .: "mod_path"
      <*> o .: "res_file"
      <*> o .: "modules"
  parseJSON _ = error "Error Parsing Config file "

border = concat $ replicate 30 "="

getMods :: String -> String -> IO String
getMods mod_path mod_name = do
  dir_files <- getDirectoryContents $ mod_path ++ "/" ++ mod_name
  let mod_files = filter (isSuffixOf ".lua") dir_files
      header = ["-- " ++ border, "--    MOD : " ++ mod_name, "-- " ++ border]
      lua_mods = map (\mod -> "require(\"" ++ mod_name ++ "." ++ mod ++ "\")") mod_files
      lua_res = header ++ lua_mods
  return $intercalate "\n" lua_res

writeMods :: [String] -> String -> IO ()
writeMods lua_mods res_file =
  writeFile (res_file ++ ".lua") $intercalate "\n" $banner ++ lua_mods
  where
    banner = ["-- " ++ border, "-- GENERATED BY V MOD LOADER : )", "-- " ++ border ++ "\n\n"]

getConfig :: FilePath -> IO ModConfig
getConfig conf_file = do
  file <- decodeFileEither conf_file :: IO (Either ParseException ModConfig)
  case file of
    Left pe -> error $prettyPrintParseException pe
    Right mc -> return mc

sanitizePath :: ModConfig -> Maybe ModConfig
sanitizePath ModConfig {mod_path, res_file, modules} =
  do
    let res = fromString res_file
        md_p
          | last mod_path == '/' = init mod_path
          | otherwise = mod_path
        res_f
          | ".lua" `isSuffixOf` res_file = unpack <$> stripSuffix ".lua" res
          | otherwise = Just res_file
    res_f >>= (\res -> Just $ ModConfig md_p res modules)
